# The string below contains Dan Bernstein's reference implementation
# of his chacha stream cipher, with small modifications to make it
# conform to RFC 7359.  The modified version uses a 32 bit counter
# and a 96 bit nonce instead of a 64 bit counter and 64 bit nonce.
# It also changes the signature of the ivsetup function to provide
# separate arguments for the counter and nonce.
#
# The string will be interpreted as verbatim C code by the Cython
# compiler, so these functions will be compiled and included in the
# Python extension module generated by Cython.

cdef extern from 'portable.h':
    r"""
/*
chacha-ref.c version 20080118
D. J. Bernstein
Public domain.
*/

/* Uncomment the next line to print information for testing.
#define CHACHA_DEBUG
*/ 
#ifdef CHACHA_DEBUG
#include <stdio.h>
#endif

typedef struct {
  u32 input[16]; /* could be compressed */
} chacha_context;

#define ROTATE(v,c) (ROTL32(v,c))
#define XOR(v,w) ((v) ^ (w))
#define PLUS(v,w) (U32V((v) + (w)))
#define PLUSONE(v) (PLUS((v),1))

#define QUARTERROUND(a,b,c,d) \
  x[a] = PLUS(x[a],x[b]); x[d] = ROTATE(XOR(x[d],x[a]),16); \
  x[c] = PLUS(x[c],x[d]); x[b] = ROTATE(XOR(x[b],x[c]),12); \
  x[a] = PLUS(x[a],x[b]); x[d] = ROTATE(XOR(x[d],x[a]), 8); \
  x[c] = PLUS(x[c],x[d]); x[b] = ROTATE(XOR(x[b],x[c]), 7);

static void chacha_wordtobyte(u8 output[64], const u32 input[16])
{
  u32 x[16];
  int i;

  for (i = 0; i < 16; ++i) x[i] = input[i];
  for (i = 20; i > 0; i -= 2) {
    QUARTERROUND( 0, 4, 8,12)
    QUARTERROUND( 1, 5, 9,13)
    QUARTERROUND( 2, 6,10,14)
    QUARTERROUND( 3, 7,11,15)
    QUARTERROUND( 0, 5,10,15)
    QUARTERROUND( 1, 6,11,12)
    QUARTERROUND( 2, 7, 8,13)
    QUARTERROUND( 3, 4, 9,14)
  }
  for (i = 0; i < 16; ++i) x[i] = PLUS(x[i], input[i]);
#ifdef CHACHA_DEBUG
  for (i = 0; i < 16; i += 4) {
    fprintf(stderr, "%08x, %08x, %08x, %08x\n", x[i], x[i + 1], x[i + 2], x[i + 3]);
  }
#endif
  for (i = 0; i < 16; ++i) U32TO8_LITTLE(output + 4 * i, x[i]);
}

void chacha_init(void)
{
  return;
}

static const char sigma[16] = "expand 32-byte k";
static const char tau[16] = "expand 16-byte k";

void chacha_keysetup(chacha_context *x, const u8 *k, u32 kbits, u32 ivbits)
{
  const char *constants;

  x->input[4] = U8TO32_LITTLE(k + 0);
  x->input[5] = U8TO32_LITTLE(k + 4);
  x->input[6] = U8TO32_LITTLE(k + 8);
  x->input[7] = U8TO32_LITTLE(k + 12);
  if (kbits == 256) { /* recommended */
    k += 16;
    constants = sigma;
  } else { /* kbits == 128 */
    constants = tau;
  }
  x->input[8] = U8TO32_LITTLE(k + 0);
  x->input[9] = U8TO32_LITTLE(k + 4);
  x->input[10] = U8TO32_LITTLE(k + 8);
  x->input[11] = U8TO32_LITTLE(k + 12);
  x->input[0] = U8TO32_LITTLE(constants + 0);
  x->input[1] = U8TO32_LITTLE(constants + 4);
  x->input[2] = U8TO32_LITTLE(constants + 8);
  x->input[3] = U8TO32_LITTLE(constants + 12);
}

/* 
For RFC7539:
   Adds a counter argument.
   Uses a 32 bit counter and 96 bit nonce.
*/

void chacha_ivsetup(chacha_context *x, const u32 counter, const u8 *nonce)
{
  x->input[12] = counter;
  x->input[13] = U8TO32_LITTLE(nonce + 0);
  x->input[14] = U8TO32_LITTLE(nonce + 4);
  x->input[15] = U8TO32_LITTLE(nonce + 8);
}

void chacha_encrypt_bytes(chacha_context *x, const u8 *m, u8 *c, u32 bytes)
{
  u8 output[64];
  int i;

  if (!bytes) return;
  for (;;) {
    chacha_wordtobyte(output, x->input);
    x->input[12] = PLUSONE(x->input[12]);
    if (bytes <= 64) {
      for (u32 i = 0; i < bytes; ++i) c[i] = m[i] ^ output[i];
      return;
    }
    for (i = 0; i < 64; ++i) c[i] = m[i] ^ output[i];
    bytes -= 64;
    c += 64;
    m += 64;
  }
}

void chacha_decrypt_bytes(chacha_context *x, const u8 *c, u8 *m, u32 bytes)
{
  chacha_encrypt_bytes(x, c, m, bytes);
}

void chacha_keystream_bytes(chacha_context *x, u8 *stream, u32 bytes)
{
  u32 i;
  for (i = 0; i < bytes; ++i) stream[i] = 0;
  chacha_encrypt_bytes(x, stream, stream, bytes);
}
    """
    ctypedef struct chacha_context:
        unsigned int input[16]
    ctypedef unsigned int u32
    ctypedef unsigned char u8
    void chacha_wordtobyte(u8 *output, u32 *input)
    void chacha_init()
    void chacha_keysetup(chacha_context *x, const u8 *k, u32 kbits, u32 ivbits)
    void chacha_ivsetup(chacha_context *x, const u8 counter, const u8 *nonce)
    void chacha_encrypt_bytes(chacha_context *x, const u8 *m, u8 *c, u32 bytes)
    void chacha_decrypt_bytes(chacha_context *x, const u8 *m, u8 *c, u32 bytes)
    void chacha_keystream_bytes(chacha_context *x, u8 *stream, u32 bytes)

from libc.stdlib cimport malloc, free
from cpython.bytes cimport PyBytes_FromStringAndSize

def encrypt(bytes key, bytes nonce, bytes plaintext, u32 counter=0):
    cdef chacha_context context
    cdef Py_ssize_t length = len(plaintext)
    cdef u8* ciphertext = <u8*>malloc(length)
    cdef bytes result
    assert len(nonce) == 12
    # The init function is a no-op for this cipher.
    # chacha_init()
    # We use a 32 byte key and a 16 byte initial value.
    chacha_keysetup(&context, key, 256, 128)
    chacha_ivsetup(&context, counter, nonce) 
    chacha_encrypt_bytes(&context, plaintext, ciphertext, length)
    result = PyBytes_FromStringAndSize(<char *>ciphertext, length)
    free(ciphertext)
    return result
